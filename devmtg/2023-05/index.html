<!--#include virtual="../../header.incl" -->

<div class="www_sectiontitle">2023 European LLVM Developers' Meeting</div>
<div style="float:left; width:68%;">
<br>
<div style="width:100%;">
<img src="">
<table><tr>
<td valign="top">
<ol>
        <li><a href="#about">About</a></li>
	    <li><a href="#program">Program</li>
        <li><a href="#coc">Code of Conduct</a></li>
        <li><a href="#contact">Contact</a></li>
</ol>
</td>

<td valign="top">
<ul>
   <li><b>Conference Dates</b>: May 10-11, 2023</li>
   <li><b>Location</b>: <a href="https://www.hilton.com/en/hotels/glagwdi-doubletree-glasgow-central/">DoubleTree By Hilton, Glasgow, Scotland</a></li>
   <li><b>Event Site: <a href=""></a></li>
</ul>
</td>
</tr></table>
</div>

<div class="www_sectiontitle" id="about">About</div>

<p>The LLVM Developers' Meeting is a bi-annual gathering of the entire LLVM Project community. The conference is organized by the LLVM Foundation and many volunteers within the LLVM community. Developers and users of LLVM, Clang, and related subprojects will enjoy attending interesting talks, impromptu discussions, and networking with the many members of our community. Whether you are a new to the LLVM project or a long time member, there is something for each attendee.
</p>
<p>To see the agenda, speakers, and register, please visit the Event Site here: COMING SOON</p>
<p>What can you can expect at an LLVM Developers' Meeting?
<dl>
<dt><b>Technical Talks</b></dt>
<dd>These 20-30 minute talks cover all topics from core infrastructure talks, to project's using LLVM's infrastructure. Attendees will take away technical information that could be pertinent to their project or general interest.</li>
<br></dd>

<dt><b>Tutorials</b></dt>
<dd>Tutorials are 50-60 minute sessions that dive down deep into a technical topic. Expect in depth examples and explanations.</dd>

<dt><b>Lightning Talks</b></dt>
<dd>These are fast 5 minute talks that give you a taste of a project or topic. Attendees will hear a wide range of topics and probably leave wanting to learn more.</dd>

<dt><b>Quick Talks</b></dt>
<dd>Quick 10 minute talks that dive a bit deeper into a topic, but not as deep as a Technical Talk.</dd>

<dt><b>Student Technical Talks</b></dt>
<dd>Graduate or Undergraduate students present their work using LLVM.</dd>

<dt><b>Panels</b></dt>
<dd>Panel sessions are guided discussions about a specific topic. The panel consists of ~3 developers who discuss a topic through prepared questions from a moderator. The audience is also given the opportunity to ask questions of the panel.
</dd>

</dl>

</p>

<p>What types of people attend?
<ul>
<li>Active developers of projects in the LLVM Umbrella
(LLVM core, Clang, LLDB, libc++, compiler_rt, flang, lld, MLIR, etc).</li>
<li>Anyone interested in using these as part of another project.</li>
<li>Students and Researchers</li>
<li>Compiler, programming language, and runtime enthusiasts.</li>
<li>Those interested in using compiler and toolchain technology in novel
and interesting ways.</li>
</ul>

<p>The LLVM Developers' Meeting strives to be the <i>best conference</i> to meet other LLVM developers and users.</p>

<p>For future announcements or questions: Please visit the LLVM Discourse forums. Most posts are in the Announcements or Community categories and tagged with EuroLLVM.</p> 

<div class="www_sectiontitle" id="program">Program</div>

<p>
<b>Keynotes</b>
</p>

<p>
Order out of Chaos, The LLVM Release Process [ Video ] [ <a href="slides/TechnicalTalks-May10/01-Tobias Hieta-LLVM-Release-Process.pdf">Slides</a> ]<br>
<i>Tobias Hieta, Ubisoft</i><br>
<br>In this Talk, I will explain how the LLVM release process works. How fixes are created, staged, tested, and reviewed to be included in a release and how community members can get involved and help improve future releases of LLVM.</br>
</p>

<p>
“-fbounds-safety”: Enforcing bounds safety for production C code [ Video ] [ <a href="slides/TechnicalTalks-May11/01-Na-fbounds-safety.pdf">Slides</a> ]<br>
<i>Yeoul Na, Apple</i><br>
<br>In this talk we will describe “-fbounds-safety”, a new language extension implemented in Clang that brings bounds safety to the C language. The language extension addresses multiple of the practical challenges that have made existing approaches to safer C dialects difficult to adopt. Our approach facilitates incremental adoption by preserving source compatibility with standard C and preserving ABI-compatibility with C binaries. It also minimizes adoption effort by reconciling wide pointers (a.k.a. “fat” pointers) with ABI-preserving bounds annotations. “-fbounds-safety” has been adopted on millions of lines of production C code and proven to work in an industrial setting.</br>
</p>

<p>
<b>Technical Talks</b>
</p>

<p>
Title [ Video ] [ <a href="slides/TechnicalTalks-May10/07-TomEccles-JeffNiu-MLIRDataflowAnalysis.pdf">Slides</a> ]<br>
<i>Tom Eccles, Arm & Jeff Niu, Modular</i><br>
<br>Abstract</br>
</p>

<p>
MLIR-based offline memory planning and other graph-level optimizations for xcore.ai [ Video ] [ <a href="slides/TechnicalTalks-May10/06-Panickal-MLIROfflineMemoryPlanning.pdf">Slides</a> ]<br>
<i>Deepak Panickal, XMOS</i><br>
<br>In this talk, we will give a walk-through of our MLIR-based graph compiler optimizing TensorFlow Lite models to be deployed on the xcore.ai microcontroller. We focus specifically on MLIR passes for memory usage reduction, such as offline memory planning, operator splitting, and streaming constants from flash, along with other passes. We leverage open-source projects such as MLIR, Tensorflow, and tflite-micro-compiler to create a small executable within various resource constraints. In contrast to other compilers in the LLVM world, we do not lower to LLVM IR. Instead, we produce C++ source code using tflite-micro-compiler, which is compiled and executed by our toolchain. We will go through some of the challenges in our journey and future plans. All code for the graph compiler and runtime is available publically on GitHub.</br>
</p>

<p>
A Rusty CHERI: The path to hardware capabilities in Rust [ Video ] [ Slides ]<br>
<i>Lewis Revill, Embecosm</i><br>
<br>Can we make unsafe Rust code safer with hardware capabilities? This talk
presents the motivation behind our effort to support CHERI (Capability Hardware
Enhanced RISC Instructions) in Rust, the challenges involved in modifying the
Rust compiler to achieve this, and the current state of Rust/CHERI (hopefully
with a demo).</br>
</p>

<p>
Extending the AArch32 JITLink backend [ Video ] [ <a href="slides/TechnicalTalks-May10/04-Granitz-ExtendingtheAArch32 -JITLinkBackend.pdf">Slides</a> ]<br>
<i>Stefan Gränitz, echtzeit.dev</i><br>
<br>Practical advice on llvm-jitlink-executor, JITLink development and debugging of JITed ARM/Thumb code</br>
</p>

<p>
Using MLIR to Optimize Basic Linear Algebraic Subprograms [ Video ] [ <a href="slides/TechnicalTalks-May10/08-Varoumas-UsingMLIR-to-OptimizeBasicLinearAlgebraicSubprograms.pdf">Slides</a> ]<br>
<i>Steven Varoumas, Huawei Technologies Research & Development</i><br>
<br>The powerful framework provided by MLIR has the potential to allow library developers to express and optimize standard linear algebra functions without having to write daunting assembly code. In this presentation, we will describe how we have leveraged and extended the capabilities of MLIR to generate an optimized subset of BLAS functions, with performance comparable to hand-written assembly implementations.</br>
</p>

<p>
Buddy Compiler: An MLIR-based Compilation Framework for Deep Learning Co-design [ Video ] [ <a href="slides/TechnicalTalks-May10/09-Zhang-Buddy Compiler_An MLIR-BasedCompilationFramework-for-DeepLearningCo-Design.pdf">Slides</a> ]<br>
<i>Hongbin Zhang, Institute of Software Chinese Academy of Sciences</i><br>
<br>Buddy Compiler is a compiler framework for software and hardware co-design. We are committed to building an extensible co-design ecosystem based on MLIR and RISC-V. This talk will share our co-design process in deep learning inference, including preprocessing, optimization, and backend support. Furthermore, we will also present our plans and current progress on DSL (Domain-Specific Language) to DSA (Domain-Specific Architecture) co-design.</br>
</p>

<p>
MachineScheduler - fine grain resource allocation using resource intervals [ Video ] [ <a href="slides/TechnicalTalks-May11/03-Petrogalli-StartAtCycle.pdf">Slides</a> ]<br>
<i>Francesco Petrogalli, Apple</i><br>
<br>In this talk we will describe an optimisation introduced in the MachineScheduler that allows to allocate more resources in a smaller number of cycles. To achieve this, we introduced the concept of resource interval and look for empty slots when tracking resource usage at a schedule boundary.</br>
</p>

<p>
Inliner in MLIR [ Video ] [ <a href="slides/TechnicalTalks-May11/10-Absar-Inliner_in_MLIR.pdf">Slides</a> ]<br>
<i>Javed Absar, Qualcomm</i><br>
<br>We give an overview of the Inliner in MLIR. The Inliner strikes a balance by defining interfaces that define the expectations and can handle recursive functions using a history-based scheme. This talk will cover Inlining in MLIR, and touch upon optimizations in general in MLIR.
</br>
</p>

<p>
How to use llvm-debuginfo-analyzer tool [ Video ] [ <a href="slides/TechnicalTalks-May11/09-Ensico-llvm-debuginfo-analyzer.pdf">Slides</a> ]<br>
<i>Carlos Alberto Enciso, SN Systems (Sony Interactive Entertainment)</i><br>
<br>Developed at Sony, llvm-debuginfo-analyzer is a command-line tool added recently to LLVM. This talk will present a more detailed information on how to use the tool, with specific test cases that cover the most common options. In addition, it will enumerate current limitations and future work.</br>
</p>

<p>
Practical Global Merge Function with ThinLTO [ Video ] [ <a href="slides/TechnicalTalks-May10/03-Lee-PracticalGlobalMergeFunction-with-ThinLTO.pdf">Slides</a> ]<br>
<i>Kyungwoo Lee, Meta</i><br>
<br>Function merging is an important technique for reducing code size by combining identical or similar functions into a single function. This technique has been extensively researched in both industry and academia. However, the existing methodologies have not been evaluated with -Oz, which includes aggressive outlinings, and the linker's identical code folding, which can already fold identical pieces of code. Additionally, none of these methodologies suggest a sound approach that works globally with ThinLTO, which is crucial when building large apps. In this talk, we propose our global merge function (GMF), which utilizes global merge information obtained from a prior codegen run and optimistically creates merging instances within each module context independently. Our evaluation showed that GMF can reduce code size in real-world iOS apps by up to 3.5% on top of state-of-the-art outliners that are fully enabled with ThinLTO.</br>
</p>

<p>
Prototyping MLIR in Python [ Video ] [ <a href="slides/TechnicalTalks-May11/05-Fehr-PrototypeMLIRinPython.pdf">Slides</a> ]<br>
<i>Sasha Lopoukhine, University of Edinburgh & Mathieu Fehr, University of Edinburgh</i><br>
<br>We present xDSL, a reimplementation of MLIR core features in pure Python with a focus on accessibility. xDSL aims at bridging the Python DSL community with the MLIR one, by being fully compatible with MLIR through the textual format. Dialects can as well be translated from one framework to the other through IRDL. Since xDSL is written in pure Python, it lowers the barrier of entry for newcomers, and allows them to learn about MLIR concepts without having the struggle of installing MLIR, and can even do so directly on a Jupyter notebook hosted on the web. It is also a good option for prototyping dialects, since no recompilation is required in between changes, resulting in faster iteration time.</br>
</p>

<p>
What would it take to remove debug intrinsics? [ Video ] [ <a href="slides/TechnicalTalks-May11/08-Morse-RemoveDebugIntrinsics.pdf">Slides</a> ]<br>
<i>Jeremy Morse, SN Systems (Sony Interactive Entertainment)</i><br>
<br>It is a truth universally acknowledged that representing LLVMs debug-info with intrinsics is a poor design, slowing compile-time performance and creating new categories of bugs. However, removing them is not easy as our APIs lack a way of describing instruction positions from outside of the instruction list. In this talk I'll illustrate what's bad about the current design and explore the design space of possible solutions. I'll also suggest what information a new instruction-movement API would need to maintain debug-info if we didn't use intrinsics. Having a more precise API for describing instruction movement will ease the work of pass authors in getting debug-info correct, and rid optimisation passes of many footguns.
</br>
</p>

<p>
Compiling Ruby (with MLIR) [ Video ] [ <a href="slides/TechnicalTalks-May11/06-Denisov-CompilingRubyWithMLIR.pdf">Slides</a> ]<br>
<i>Alex Denisov</i><br>
<br>Ever wondered how to build an ahead-of-time (AOT) compiler for a dynamic, interpreted language? Then this talk is a good starting point.
In this presentation, you'll learn how a typical interpreter works, how to map it onto an intermediate representation (MLIR in this case), and how to produce an executable at the end of the compilation pipeline. By the end of this talk, we hope to inspire you to take on the challenge of building a compiler for your favorite interpreted language.</br>
</p>

<p>
What’s new in MLIR? [ Video ] [ Slides ]<br>
<i>Mehdi Amini</i><br>
<br>Abstract</br>
</p>

<p>
Structured Bindings and How to Analyze Them [ Video ] [ <a href="slides/TechnicalTalks-May11/02-Domjan-StructuredBindingsCombined.pdf">Slides</a> ]<br>
<i>Domján Dániel, Company</i><br>
<br>A deeper dive into how structured bindings are handled inside the Clang Static Analyzer. The process involves multiple parts of the analyzer throughout the static analysis pipeline. This speech will give an insight into all the steps and tricks used in the implementation.</br>
</p>

<p>
MLIR Dialect Design and Composition for Front-End Compilers [ Video ] [ Slides ]<br>
<i>Jeff Niu, Modular</i><br>
<br>MLIR dialect design is often more an art than a science. MLIR provides powerful infrastructure for building IR and a vast ecosystem of dialects to use, but lacks guidelines on how to actually do so. This talk is a deep dive on principles for MLIR dialect design and composition. We will focus on criteria for dialect design, such as concise and powerful representation and transparent composability, dialect design principles and techniques, such as preserving high-level information and distinguishing between “structural” and “computation” dialects, and challenges with integrating with upstream dialects. We will study how good dialect design allows us efficiently and easily write powerful optimizations on our IR and how to write generic IR transformations with MLIR interfaces. We will present our findings through the lens of building a general-purpose programming language with MLIR.</br>
</p>

<p>
ML-LLVM-Tools: Towards Seamless Integration of Machine Learning in Compiler Optimizations [ Video ] [ <a href="slides/TechnicalTalks-May10/10-Venkat-ML-LLVM-Tools.pdf">Slides</a> ]<br>
<i>S. VenkataKeerthy, IIT Hyderabad</i><br>
<br>With the growth in usage of Machine Learning (ML) to support compiler optimization decisions, there is a need for robust tools to support both training and inference. Such tools should be scalable and independent of the underlying model, and the ML framework upon which the model is built. We propose a unified infrastructure to aid ML based compiler optimizations in LLVM at each of training and inference stages by using: (1) LLVM-gRPC, a gRPC based framework to support training, (2) LLVM-InferenceEngine, a novel ONNX based infrastructure to support ML inference within LLVM.  Our infrastructure allows seamless integration of both the approaches with ML based compiler optimization passes. When our LLVM-InferenceEngine is integrated with a recently proposed approach that uses Reinforcement Learning for performing Register Allocation, it results in a 12.5x speedup in compile time.</br>
</p>

<p>
Optimizing the Linux Kernel with LLVM BOLT [ Video ] [ <a href="slides/TechnicalTalks-May10/11-Panchenko-Optimizing-the-LinuxKernel-with-LLVM BOLT.pdf">Slides</a> ]<br>
<i>Maksim Panchenko, Meta</i><br>
<br>This technical talk explores the challenges and benefits of applying LLVM BOLT optimizations to the Linux Kernel, given its unique binary structure and compiled code. Early performance results are shared, and attendees gain insights into kernel-specific code patterns and improvements that can be achieved with post-link optimizations.</br>
</p>

<p>
mlir-meminfo : A Memory Model for MLIR [ Video ] [ Slides ]<br>
<i>Kunwar Grover, IIIT Hyderabad & Arjun Pitchanathan, University of Edinburgh</i><br>
<br>A number of transformations in high-level MLIR dialects like Linalg, SCF and Affine focus on building transformations for optimizing the cache behavior of programs. While building models for the cost of computation for these transformations are easy as it is a local property, data movement on cached architectures depends on the global state and is very hard to predict. Current approaches for memory models for these transformations use transformation-specific cost models, which do not compose from one transformation to another due to the global properties of data movement. We introduce mlir-meminfo, a lightweight, analytical memory model for MLIR. mlir-meminfo accurately predicts the cache behavior of a program, with a particular focus on transformations, updating the cache information almost instantly for modern neural networks like BERT, containing hundreds of memory accesses. With the introduction of mlir-meminfo, we aim to revolutionize transformation memory models for MLIR and improve developer productivity for performance programming.</br>
</p>

<p>
<b>Tutorials</b>
</p>

<p>
Developing BOLT pass [ Video ] [ Slides ]<br>
<i>Amir Ayupov, Meta</i><br>
<br>The tutorial covering the basics of BOLT pass development and debugging techniques, with examples of adding a simple peephole rule and a standalone pass. Debugging examples cover narrowing down a misoptimized function, producing an assembly test and visualizing the CFG.</br>
</p>

<p>
A whirlwind tour of the LLVM optimizer [ Video ] [ Slides ]<br>
<i>Nikita Popov, Red Hat</i><br>
<br>This is a tour of LLVM's optimization pipeline: It provides an overview of all important optimization passes and analyses, as well as how they work together and fit into the overall optimization pipeline.</br>
</p>

<p>
Tutorial: Controllable Transformations in MLIR [ Video ] [ Slides ]<br>
<i>Name, Company</i><br>
<br>MLIR has recently introduced support for declaratively specifying and controlling compiler transformations via the transform dialect. It allows one to request compiler transformations using compiler IR itself, which can be embedded into the original IR that is being transformed (similarly to pragmas) or supplied separately (similarly to scheduling languages). This tutorial presents the concepts of the MLIR transform dialect and related infrastructure. It will be accompanied by a practical demonstration of three use scenarios.
<ul>
<li>Composing transform dialect operations available in (upstream) MLIR to perform a sequence of optimizing transformations that results in efficient code for an MLIR linear algebra operation.</li>
<li>Defining new transform dialect operations and adapting existing transformation code to work with the transform dialect infrastructure.</li>
<li>Setting up and using the transform dialect infrastructure in a downstream out-of-tree project with custom dialects, transformations and passes.</li>
</ul>
After following the tutorial, the attendees will be able to apply the transform dialect in their work and extend it when necessary. Basic familiarity with MLIR is a prerequisite.</br>
</p>

<p>
GlobalISel by example [ Video ] [ Slides ]<br>
<i>Alex Bradbury, Igalia</i><br>
<br>The GlobalISel framework was introduced with the intention of replacing SelectionDAG, aiming to provide advantages in terms of performance, granularity, and modularity. This tutorial will provide everything you need to know about using this framework for a new target, focusing on RISC-V as an example and working through some specific examples of challenging cases.</br>
</p>

<p>
<b>Quick Talks</b>
</p>

<p>
Iterative Compilation - Give the compiler a second chance [ Video ] [ Slides ]<br>
<i>Ziv Ben Zion, Mobileye</i><br>
<br>Compiler heuristics play a crucial role in improving the performance of generated code. Revisiting some of the decisions taken by the compiler is possible using different compilation flags, and can sometimes overcome wrong compiler decisions. This talk introduces a different approach, where the compiler itself triggers new compiler runs with different heuristics. I will briefly outline how we implemented this new approach in our LLVM-based compiler.</br>
</p>

<p>
Another level of indirection - Compiler Fallback of load/store into gather/scatter enhance compiler robustness by overcoming analysis and hardware limitations [ Video ] [ Slides ]<br>
<i>Omer Aviram, Mobileye</i><br>
<br>I'll introduce a recently developed LLVM-IR utility that can improve compilers robustness, by converting ("fallback") memory accesses (load/store) with a constant stride, into indirect accesses (scatter/gather); Discuss interesting cost decisions raised by such transformations; as well as the technical challenges faced in transforming load/store instructions with a single pointer into gather/scatter instructions with a vector of pointers.</br>
</p>

<p>
Switch per function in LLVM [ Video ] [ Slides ]<br>
<i>Tomer Nissim Schneider, CEVA</i><br>
<br>At CEVA, we have found that more optimizations and compiler hints are extremely essential for optimizing code of our customers.​ We added support for clang switches as function attributes.</br>
</p>

<p>
Tensor Evolution - An ML Graph Optimization Technique [ Video ] [ Slides ]<br>
<i>Javed Absar, Qualcomm & Muthu Baskaran, Qualcomm</i><br>
<br>We present ‘Tensor Evolution (TEV)’, a new analysis for tensors such as those found in loops of ML Graphs. It is an extension of the well-known Scalar Evolution (SCEV) for tensors and tensor expressions. In an ML Graph, tensors can be added, multiplied, sliced, reshaped, and concatenated. We describe how each of these tensor-ops could be handled to generate TEV-expressions and rewrite rules. TEV is an analysis that enables  optimizations such as loop-invariant code motion.</br>
</p>

<p>
ML-on-CPU: should vectorization happen in the LLVM backend or higher up the stack? [ Video ] [ Slides ]<br>
<i>Elen Kalda, Arm</i><br>
<br>This talk is about how TVM, one of the most mature machine learning compilation stacks in ML space, interacts with LLVM. TVM is a domain specific compiler that consumes a machine learning model expressed in high level ML framework like TensorFlow or PyTorch and compiles it for a chosen target, such as Arm(R) architecture. For CPU targets, it does this by using LLVM as a backend, directly translating TVM's IR into LLVM IR.
</br><br>
In TVM, just like in other Machine Learning stacks using LLVM as a backend for CPU code generation, one needs to make a decision about where optimizations like vectorization should happen: in the LLVM backend, or in the ML stack higher up. This is further complicated by the emergence of scalable vectors, like the Scalable Vector Extension (SVE). While generating code for fixed length vectors can mostly be left to LLVM, there is a case to be made for the presence of variable length vectors in TVM stack, to be able to more effectively use the capabilities of SVE. In this talk, we're going to present our experiences and insights on the trade-offs targeting SVE in the TVM+LLVM stack.</br>
</p>

<p>
CORE-V LLVM: Adding eight vendor extensions to standard RISC-V LLVM [ Video ] [ Slides ]<br>
<i>Charlie Keaney, Embecosm</i><br>
<br>CORE-V is a family of open source commercially rust RISC-V designs from the Open Hardware Group, with a set of 8 custom instruction set extensions.  This talk will look at the practical challenges we have encountered in supporting vendor specific extensions to RISC-V in LLVM.  This has been a collaborative project across several organizations on two continents, and with an additional objective of training a new generation of LLVM developers in China and Europe.</br>
</p>

<p>
Advanced Bug Reports: Choose Your Own Adventure [ Video ] [ Slides ]<br>
<i>Arseniy Zaostrovnykh, SonarSource SA</i><br>
<br>Finding actual bugs using the Clang Static Analyzer (CSA) is only half of the story. Getting bugs fixed also requires convincing developers that those bugs are real. Traditional bug reports, however, are typically either too short and miss important details, or too long such that they overwhelm developers with information. This talk presents a novel approach to make CSA-bug-reports interactive to confront developers with exactly the amount of information they need to understand and confirm a bug.</br>
</p>

<p>
Multiple-Entry, Multiple-Exit MLIR Regions [ Video ] [ Slides ]<br>
<i>Jeff Niu, Modular</i><br>
<br>MLIR regions provide a natural representation of structured control-flow found in many applications, with implicit SSA value captures and automatic memory scopes, but they have been limited to single-entry, single-exit regions. In this talk, we present a new MLIR region-based control-flow representation for single-entry, multiple-exit regions and how this provides a faithful IR model of control-flow in source languages. We also integrated LLVM coroutine intrinsics in our compiler, and we will discuss how they interact with our control-flow representation and how the latter enables trivial implementations of coroutine frame optimizations.</br>
</p>

<p>
Target-Independent Integer Arithmetic [ Video ] [ Slides ]<br>
<i>Jeff Niu, Modular</i><br>
<br>How can you fold address arithmetic without knowing the maximum machine integer size? How about C integer types with variable widths? What about range analysis? Folding target-independent IR is important in producing target-agnostic serialization, where introducing a target can cause invalid arithmetic semantics. This talk will present a formulation for target-independent integer arithmetic, its limitations, and how it was implemented in MLIR.</br>
</p>

<p>
Improving Vectorization for Loops with Control Flow [ Video ] [ Slides ]<br>
<i>Ashutosh Nema, AMD</i><br>
<br>Auto-vectorization is an essential compiler optimization. In the presence of control flow, it gets challenging. We introduce the implementation of Branch-On-Super-Word-Conditional-Codes (BOSCC) way of vectorization in the presence of conditional statements. BOSCC introduces a branch instruction that can be conditionally taken based on the comparison result of two vector variables. BOSCC encloses the vector instructions guarded by vector predicate inside an if-statement.</br>
</p>

<p>
How to run the LLVM-Test Suite on GPUs and what you’ll find [ Video ] [ Slides ]<br>
<i>Johannes Doerfert, LLNL</i><br>
<br>Running codes on GPUs is nowadays pretty easy. However, testing GPU compilation on a large, well-understood selection of codes is not. We present an automated approach that allows running (most) existing codes on the GPU in order to test the optimizations and backends. We present our findings from running (most of) the LLVM Test Suite on modern GPUs and show how we combine existing functionality to create concise GPU reducers for bugs.</br>
</p>

<p>
OpenMP as GPU Kernel Language [ Video ] [ Slides ]<br>
<i>Johannes Doerfert, LLNL</i><br>
<br>In this talk, we discuss the use of OpenMP as a kernel language (think CUDA or HIP). While OpenMP comes with offloading capabilities, the execution model was different and generally associated with overheads. Further, the user did not have the same level of control, at least not without target-specific builtins. With our new OpenMP extensions, we can match native CUDA (and HIP) codes while retaining the portability of OpenMP as well as interoperability with the existing capabilities.</br>
</p>

<p>
<b>Lightning Talks</b>
</p>

<p>
LLVM IR as an Embedded Domain-Specific Language [ Video ] [ Slides ]<br>
<i>Nikita Baksalyar</i><br>
<br>This lightning talk will demonstrate an alternative way of using the LLVM API. We will develop a simple domain-specific language using metaprogramming techniques and see how it simplifies code and reduces boilerplate.</br>
</p>

<p>
Using MLIR for Dalvik Bytecode Analysis [ Video ] [ Slides ]<br>
<i>Eduardo Blázquez, University Carlos III of Madrid</i><br>
<br>Using intermediate representations allows analysts to write optimizations and code analysis passes easier than parsing binary or bytecode directly. Kunai is a library intended for static analysis of dalvik bytecode, in a newer version of the library, the idea is to use the capabilities and possibilities offered by MLIR, writing a new dialect centered on Dalvik instructions.</br>
</p>

<p>
Spot the Difference with LLVM-FLOW: an open-source interactive visualization tool for comparing IR CFGs [ Video ] [ Slides ]<br>
<i>Jinmyoung Lee, KC Machine Learning Lab</i><br>
<br>One way to understand and debug IR optimization process is to visualize Control Flow Graphs (CFGs) before and after optimization and compare them. However, since the CFGs can be drastically different, comparing these two graphs is a challenging task.
LLVM-FLOW (https://llvmflow.kc-ml2.com/), an open-source interactive CFG visualization web app, is developed to ease the difficulty by highlighting the same components in two graphs. By clicking the highlighted node, you can easily find the corresponding node in another graph. LLVM-FLOW is a useful tool for LLVM experts to understand the IR flow when writing a custom pass, as well as for LLVM newcomers to study the IR pattern's behavior.</br>
</p>

<p>
Leveraging MLIR for Better SYCL Compilation [ Video ] [ Slides ]<br>
<i>Victor Lomüller, Codeplay Software</i><br>
<br>SYCL is an open standard programming model for heterogeneous device programming, based on C++. Similar to optimizing C++ compilers, SYCL compilers would therefore also profit from a more suitable high-level representation for optimization. This talk presents first results on our investigation on how MLIR can be leveraged to improve SYCL compilation flows and optimizations.</br>
</p>

<p>
Arm/AArch64 Embedded Development with LLD : What’s New [ Video ] [ Slides ]<br>
<i>Amilendra Kodithuwakku, Arm Limited</i><br>
<br>Arm Limited has been continuously adding LLD support for embedded development on Arm/AArch64 targets. This lightning talk will be a short explanation of recently added features. 1) Armv8-M Security Extensions, also known as, Cortex-M Security Extensions (CMSE) 2) AArch64 Big Endian Support</br>
</p>

<p>
Using automated tests to tune the -Og pipeline [ Video ] [ Slides ]<br>
<i>Stephen Livermore-Tozer, SN Systems (Sony Interactive Entertainment)</i><br>
<br>In clang, the -Og flag is intended to run optimizations that will not significantly reduce the quality of the program's debug information. Rather than making informed decisions about which optimizations will preserve debug info, this flag currently uses the -O1 pipeline, to run a few optimizations and hope that debug info will not be significantly affected. This is due to the lack of useful data about how well the various optimization passes in LLVM preserve debug info. In this talk I explain how we at Sony have attempted to solve this problem using Dexter, a tool for testing debug info quality, in an automated test pipeline to empirically explore different pipeline designs to find a fast and debuggable -Og pipeline.</br>
</p>

<p>
Buddy-CAAS: Compiler As A Service for MLIR [ Video ] [ Slides ]<br>
<i>Hongbin Zhang, Institute of Software Chinese Academy of Sciences</i><br>
<br>This talk will introduce the Buddy-CAAS, Buddy Compiler As A Service for MLIR. In practice, debugging and configuring an MLIR pass pipeline is always time-consuming, and there are no good aid tools. In order to improve the efficiency of compiler developers, we implemented an online platform called Buddy-CAAS (https://buddy.isrc.ac.cn/). Our platform allows MLIR developers to configure the pass pipeline, view the intermediate products, and execute on a specific backend through an emulator. We are also integrating more features on our platform to power the MLIR ecosystem.</br>
</p>

<p>
llvm-buildmark - observations, tips, and tricks on reducing LLVM build times [ Video ] [ Slides ]<br>
<i>Alex Bradbury, Igalia</i><br>
<br>This talk provides a series of statistics on LLVM build times (both incremental and in a simulation of common edit-compile-test cycles) using a simple script that aims to provide a common baseline statistic. We'll look at some figures across real-world hardware, how LLVM build performance has changed over time, and the impact of various options (e.g. -DBUILD_SHARED_LIBS=True, -DLLVM_USE_SPLIT_DWARF=True, GCC vs Clang, lld vs ld.{bfd,gold} and so on).
</br>
</p>

<p>
Lock Coarsening optimizations for loops in Java [ Video ] [ Slides ]<br>
<i>Anna Thomas, Azul Systems</i><br>
<br>This talk will focus on lock optimizations done for loops in Java by Falcon, Azul’s LLVM based JIT compiler. Synchronization is one the basic techniques that guarantee correctness in parallel execution. This is implemented using monitors in Java. Monitor acquires are expensive CPU operations, which also block various loop and reordering compiler optimizations. We will talk about two specific loop optimizations done for lock coarsening and the benefits it brings. For both these techniques, we introduced loop chunking in LLVM as a mechanism to coarsen locks over. We will go over the legality and cost model aspects as well.</br>
</p>

<p>
<b>Student Technical Talks</b>
</p>

<p>
Cost Modelling for Register Allocation and Beyond [ Video ] [ Slides ]<br>
<i>Aiden Grossman, University of California, Davis</i><br>
<br>Accurate and fast cost modeling is essential for training ML models to replace certain key heuristics within LLVM when looking for performance gains. For eviction in the LLVM greedy register allocator, we use a linear model with some domain specific features which has successfully trained highly performant ML replacements, but leaves a lot to be desired in terms of absolute accuracy. In this talk we present results on the application of more generic basic block specific cost models to this problem as well as future directions and current work to push accurate cost modeling beyond basic blocks for the application of training ML models.</br>
</p>

<p>
A Template-Based Code Generation Approach for MLIR [ Video ] [ Slides ]<br>
<i>Florian Drescher, Technical University of Munich (TUM)</i><br>
<br>In the talk, we introduce a template-based compilation approach for MLIR dialects. It derives code templates ahead-of-time for MLIR instructions using the already implemented lowerings. During run-time compilation of a program, it stitches together the created templates and patches missing constants to quickly derive native. We apply our compiler on database queries (LingoDB) as well as ONNX models and achieve compile-time speed-ups between 60x and 1000x at the cost of slower execution by the factor two to three compared to the existing LLVM compilation back-end.
In this presentation, we describe our approach for fast, template-based compilation and outline our vision on how to improve on the idea and establish template-based compilation as a new code generation approach for MLIR as an alternative to the currently used LLVM back-end.</br>
</p>

<p>
MLIR Query Tool for easier exploration of the IR [ Video ] [ Slides ]<br>
<i>Devajith Valaparambil Sreeramaswamy</i><br>
<br>This talk will introduce mlir-query, a query language tool designed to simplify the exploration of the Intermediate Representation (IR) of code in MLIR. mlir-query aims to provide a more efficient means of understanding and debugging the IR, which can be challenging without a query language. The presentation will showcase the tool's basic queries, such as operation, hasName, resultOf, and constant queries, along with a demo of its usefulness.</br>
</p>

<p>
mlirSynth: Synthesis of Domain-Specific Programs in MLIR [ Video ] [ Slides ]<br>
<i>Alexander Brauckmann, University of Edinburgh</i><br>
<br>mlirSynth is a tool that automatically raises programs to high-level MLIR dialects, using MLIR's dialect definitions, instead of relying on manually-defined rules that are difficult to maintain. Our experiments show that mlirSynth achieves higher coverage than existing rule-based approaches on the PolyBench benchmark and enables high performance through domain-specific compilation.</br>
</p>

<p>
Image Processing Ops as first class citizens in MLIR: write once, vectorise everywhere! [ Video ] [ Slides ]<br>
<i>Prathamesh Tagore, Veermata Jijabai Technological Institute</i><br>
<br>We present an MLIR dialect for Image Processing named Digital Image Processing (DIP). DIP dialect solves the problem of dependence on external tools and libraries for image pre-processing in deep learning models at the MLIR IR level. This dialect is capable of processing an image input at the IR level in the form of memrefs. We utilise MLIR’s vector dialect abstraction to generate optimal vectorisable code using a single lowering pipeline for different architectures. Additionally, we also present these operations in the form a C++ library for their higher level use. As of now, the DIP dialect supports 1D as well as 2D convolutions, resizing, rotation, FFT, IFFT and morphological transformations for images.</br>
</p>

<p>
Using the Clang data-flow framework for null-pointer analysis [ Video ] [ Slides ]<br>
<i>Viktor Cseh, Eötvös Loránd University</i><br>
<br>In late 2021 a new data-flow analysis framework was introduced into the Clang analysis tooling, enabling reasoning about program states the symbolic execution engine of the Clang Static Analyzer had difficulty deducing. In this talk, we summarize our experience with the data-flow framework through the lens of implementing a Clang-Tidy checker using null-pointer analysis. We discuss various approaches we tested to encode pointer values within the framework, their performance and limitations, and best practices and common pitfalls we encountered while implementing checkers using the framework.</br>
</p>

<p>
Fast and Vectorized Pivot Function for MLIR Presburger Library [ Video ] [ Slides ]<br>
<i>Qi Zhou</i><br>
<br>In MLIR’s presburger library for polyhedral compilation, most of the runtime is spent on doing simplex method linear programming with the pivot function. Its hot loop is element-wise overflow-checked multiplication and addition on a input matrix.
There are two methods to optimize this function through vectorization, the conventional way involves constructing matrix with int16_t and issue additional instruction to check overflow.
However, a crazy approach is is to compute 23 bits or 52 bits integer using FPU, as mantissa part of single and double precision floating point number is 23 and 52 bits. By doing this we can exploits fused-multiply-add, and most importantly, imprecise floating point operation triggers status register, making overflow checking almost free.</br>
</p>

<p>
RISC-V Vector Extension Support in MLIR: Motivation, Abstraction, and Application [ Video ] [ Slides ]<br>
<i>Hongbin Zhang, Institute of Software Chinese Academy of Sciences</i><br>
<br>This talk will share our work on supporting the RISC-V Vector (RVV) extension in MLIR. The RVV extension provides high-performance vector instructions, and the parallelism model is different from other SIMD architectures. However, MLIR vector abstractions cannot support some RVV features, especially the dynamic vector length and register group configuration. To address this issue, we add custom MLIR abstractions to support RVV parallelism model, and our design balances generic and specialized parts to avoid introducing fragmentation. As a demonstration case, we use our abstractions to implement a vectorization optimization for the matrix multiplication operation.</br>
</p>

<p>
<b>Posters</b>
</p>

<p>
Automatic Translation of C++ to Rust [ Video ] [ Slides ]<br>
<i>Henrique Preto, ULisboa - Instituto Superior Técnico</i><br>
<br>Memory safety bugs account for 70% of the security vulnerabilities found in major Microsoft and Google projects. C++, while not memory safe, is an efficient language commonly used to implement critical systems software. However, Rust is a memory-safe programming language that offers comparable performance to C++. Still, manually rewriting existing C++ codebases in Rust is not practical. This work presents a source-to-source compiler built with Clang that translates C++ code to safe Rust, automatically making the software safer without losing performance and efficiency.</br>
</p>

<p>
A sustainable approach to have vector predication in the Loop Vectorizer [ Video ] [ Slides ]<br>
<i>Lorenzo Albano, Barcelona Supercomputing Center</i><br>
<br>A number of vector ISAs, like the RISC-V Vector Extension, have support for vector length and predication. Vector Predication provides us intrinscis to express operations that map well to these ISAs. However, the Loop Vectorizer still does not make use of them. At BSC we extended the Loop Vectorizer so it can use Vector Predication intrinsics but the amount of duplication makes us reluctant to upstream it. In this poster we present an alternative that has less impact to the Loop Vectorizer and a new pass that propagates the vector length and mask to the vectorised code.</br>
</p>

<p>
Performance Analysis of Undefined Behavior Optimizations [ Video ] [ Slides ]<br>
<i>Lucian Popescu, Politehnica University of Bucharest</i><br>
<br>State-of-the-art compilers, such as Clang/LLVM, use undefined behavior (UB) to
issue optimizations. We present the impact of UB optimizations for a diverse set
of application categories to discover what are UBs that are most performance
critical.</br>
</p>

<p>
Static Analysis for C++ Rust-Like Lifetime Annotations [ Video ] [ Slides ]<br>
<i>Susana Monteiro, INESC-ID, IST ULisboa</i><br>
<br>Memory safety vulnerabilities can be addressed by incrementally migrating from memory-unsafe languages like C++ to memory-safe languages, namely Rust. However, this involves some challenges, in particular regarding Rust’s concept of lifetimes, which does not exist in C++. Recently, Clang introduced Rust-like lifetime annotations to approach this challenge, but it is essential to ensure their correctness. Our work focuses on developing a static analyzer to verify the correctness of C++ lifetime annotations, consequently addressing memory-safety vulnerabilities.</br>
</p>

<p>
Leveraging MLIR for Better SYCL Compilation [ Video ] [ Slides ]<br>
<i>Victor Lomüller, Codeplay Software</i><br>
<br>SYCL is an open standard programming model for heterogeneous device programming, based on C++. Similar to optimizing C++ compilers, SYCL compilers would therefore also profit from a more suitable high-level representation for optimization. This poster presents first results on our investigation on how MLIR can be leveraged to improve SYCL compilation flows and optimizations.</br>
</p>

<p>
Forcefully Embedding MLIR into Python [ Video ] [ Slides ]<br>
<i>George Mitenkov, ETH Zurich</i><br>
<br>While MLIR provides its users with the infrastructure to create new dialects, lowerings and rewrites to support efficient domain-specific and ML workload compilation, the front-ends that generate MLIR have not been fully explored. In particular, it is common to either write SSA-based MLIR code in high-level dialects, or re-implement the code generation flow from the source language to MLIR. Both approaches are not developer-friendly because they require maintenance and significant development effort. In this poster session, we present how MLIR can be embedded into Python, allowing one to generate non-SSA Pythonic front-ends based on the dialect specifications. Moreover, we discuss how the front-ends can be statically compiled to SSA-based MLIR or even dynamically executed. We evaluate our work by presenting examples of front-ends for zero-knowledge proof or RISC-V compilers.</br>
</p>


<div class="www_sectiontitle" id="coc">Code of Conduct</div>
<p>The LLVM Foundation is dedicated to providing an inclusive and safe
experience for everyone. We do not tolerate harassment of participants in any
form. By registering for this event, we expect you to have read and agree to
the <a href="http://llvm.org/docs/CodeOfConduct.html">LLVM Code of Conduct</a>.
</p>

<div class="www_sectiontitle" id="contact">Contact</div>
<p>To contact the organizer,
<a href="mailto:eurollvm@llvm.org"> email eurollvm@llvm.orgr</a>
</p>
</div>

<!-- *********************************************************************** -->

<!--#include virtual="sponsors.incl" -->

<hr>

<!--#include virtual="../../footer.incl" -->
